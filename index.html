<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Wolf Golf Scorer</title>
    <style>
        :root {
            --color-bg: #06130c;
            --color-bg-alt: #0d1f16;
            --color-surface: rgba(255,255,255,0.05);
            --color-surface-alt: rgba(255,255,255,0.09);
            --color-surface-strong: rgba(255,255,255,0.14);
            --color-accent: #159a55;
            --color-accent-hover: #118447;
            --color-accent-active: #0d6d3a;
            --color-accent-soft: rgba(21,154,85,0.20);
            --color-highlight: #c8ff66;
            --color-highlight-soft: rgba(200,255,102,0.28);
            --color-danger: #c84747;
            --color-danger-hover: #ac3838;
            --gradient: radial-gradient(circle at 25% 20%, #133b25 0%, #06130c 70%);
            --focus-ring: 0 0 0 2px rgba(200,255,102,0.55), 0 0 0 4px rgba(21,154,85,0.45);
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body { touch-action: manipulation; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--gradient);
            color: #f2f9f4;
            min-height: 100vh;
            padding: 0;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
            -webkit-text-size-adjust: 100%;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 0 10px 10px; /* restore spacing for main content only */
        }

        .header {
            text-align: left;
            margin-bottom: 12px;
            padding: 6px 15px;
            background: rgba(0,0,0,0.38);
            border-radius: 0;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 4px;
            position: sticky;
            top: 0;
            z-index: 100;
            margin-left: -10px;
            margin-right: -10px;
            width: calc(100% + 20px);
        }
    .header-bar { display: flex; align-items: center; justify-content: space-between; width: 100%; }
    .header h1 { font-size: 1.35rem; font-weight: 600; letter-spacing: 1px; margin: 0; color: var(--color-accent); opacity: 0.85; text-shadow: 0 0 6px rgba(21,154,85,0.25); }
        .player-card {
            background: var(--color-surface-alt);
            padding: 4px 10px;
            border-radius: 20px;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            flex: 1 1 0;
            min-width: 0;
            border: 1px solid transparent;
            transition: background .25s ease, transform .25s ease, border-color .25s ease, box-shadow .25s ease;
        }
        .player-card:hover { background: var(--color-surface-strong); transform: translateY(-2px); }
    /* Removed per request: .player-card.wolf highlight */
                .current-hole {
                    margin: 0;
                    font-size: 0.85rem;
                    font-weight: 600;
                    opacity: 0.7;
                    min-width: 54px;
                    text-align: right;
                    font-variant-numeric: tabular-nums;
                    letter-spacing: .5px;
                    padding-top: 2px;
                    cursor: pointer;
                }
                .current-hole.hidden { display:none !important; }
                .current-hole.inactive { pointer-events:none; }
                .current-hole::after {
                    content: 'üî¢';
                    font-size: 0.85rem;
                    margin-left: 6px;
                    opacity: 0.55;
                    transition: opacity .25s ease, transform .25s ease;
                    display: inline-block;
                    transform: translateY(1px);
                }
                .current-hole:hover::after { opacity: 0.9; }
                .overview-overlay:not(.hidden) ~ .header .current-hole::after,
                .overview-overlay:not(.hidden) .current-hole::after { opacity:0.95; }

        .scoreboard {
            background: var(--color-surface-alt);
            border-radius: 999px;
            padding: 4px 8px;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: stretch;
            gap: 6px;
            overflow-x: auto;
            width: 100%;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .scoreboard::-webkit-scrollbar { display: none; }


        .players-grid {
            display: flex;
            gap: 6px;
            flex: 1;
            min-width: 0;
        }

    /* removed duplicate legacy .player-card block */

        .player-name {
            font-weight: 600;
            margin-bottom: 0;
            font-size: 0.65rem;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            opacity: 0.85;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .player-name .medal {
            margin-right: 4px;
            filter: drop-shadow(0 0 3px rgba(200,255,102,0.4));
            font-size: 0.75rem;
        }

        .player-score {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--color-highlight);
            line-height: 1.1;
            text-shadow: 0 0 4px rgba(200,255,102,0.35);
        }
        .player-score .score-value { display:inline-block; transition: color .3s ease; }
        .player-score .score-value.bump { animation: scorePop .6s ease; }
        @keyframes scorePop { 0% { transform:scale(1); filter:brightness(1); text-shadow:0 0 4px rgba(200,255,102,0.3);} 25% { transform:scale(1.3); text-shadow:0 0 10px rgba(200,255,102,0.8);} 55% { transform:scale(0.92);} 100% { transform:scale(1); text-shadow:0 0 4px rgba(200,255,102,0.35);} }
    .wolf-count { font-size: 0.55rem; font-weight: 400; color: rgba(255,255,255,0.45); margin-left: 4px; letter-spacing: .4px; position: relative; top: -1px; }
    .money-value { font-size:0.55rem; font-weight:600; color:rgba(200,255,102,0.9); margin-left:6px; letter-spacing:.4px; opacity:.85; }

        .game-setup {
            background: var(--color-surface-strong);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .setup-section {
            margin-bottom: 20px;
        }

        .setup-section h3 {
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        .btn {
            background: var(--color-accent);
            color: #fff;
            border: none;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 1.05rem;
            font-weight: 600;
            letter-spacing: .5px;
            cursor: pointer;
            width: 100%;
            margin: 5px 0;
            transition: background .25s ease, transform .25s ease, box-shadow .25s ease;
        }
        .btn:hover { background: var(--color-accent-hover); transform: translateY(-2px); }
        .btn:active { background: var(--color-accent-active); transform: translateY(0); }
        .btn:focus-visible { outline: none; box-shadow: var(--focus-ring); }

    .btn-secondary { background: var(--color-surface-alt); }
    .btn-secondary:hover { background: var(--color-surface-strong); }

        .player-count-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .btn-player-count {
            background: var(--color-surface-alt);
            font-size: 1.05rem;
            font-weight: 600;
            padding: 12px 20px;
            min-width: 60px;
            border: 2px solid transparent;
            border-radius: 14px;
            transition: background .25s ease, border-color .25s ease;
        }
        .btn-player-count:hover { background: var(--color-surface-strong); }
        .btn-player-count.selected { background: var(--color-accent); border-color: var(--color-highlight); color: #fff; }
        .btn-player-count.selected:hover { background: var(--color-accent-hover); }

    .hole-scoring { background: var(--color-surface-strong); border-radius: 15px; padding: 20px; margin-bottom: 20px; backdrop-filter: blur(10px); }

        .hole-info {
            text-align: center;
            margin-bottom: 20px;
        }

    .hole-number { font-size: 2rem; font-weight: 700; color: var(--color-highlight); text-shadow: 0 0 6px var(--color-highlight-soft); }

    .wolf-info { background: var(--color-accent-soft); padding: 14px 16px; border-radius: 14px; margin-bottom: 18px; text-align: center; border: 1px solid var(--color-accent); }
    .wolf-name { font-size: 1.05rem; font-weight: 500; color: rgba(255,255,255,0.75); letter-spacing: .5px; }
    .wolf-name .wolf-player { font-size: 1.3rem; font-weight: 700; color: var(--color-highlight); text-shadow: 0 0 6px var(--color-highlight-soft); display: inline-block; margin-left: 6px; letter-spacing: .5px; position: relative; }

        .scoring-options {
            display: grid;
            gap: 10px;
        }

    .scoring-option { background: var(--color-surface); padding: 12px 14px; border-radius: 10px; cursor: pointer; border: 1px solid var(--color-surface-alt); transition: background .2s ease, border-color .2s ease; }
    .scoring-option:hover { background: var(--color-surface-alt); }
    .scoring-option.selected { border-color: var(--color-accent); }
    .scoring-option:focus-visible { outline: none; box-shadow: var(--focus-ring); }

        .option-title {
            font-weight: bold;
        }

        .option-description {
            font-size: 0.9rem;
            opacity: 0.8;
        }




    .winner-selection { background: var(--color-surface-alt); border-radius: 12px; padding: 16px; margin: 18px 0; }
    .mode-selection { background: var(--color-surface-alt); border-radius: 12px; padding: 16px; margin: 18px 0; }
    .mode-selection h3 { text-align:center; margin:0 0 14px; font-size:1.05rem; }
    .scoring-option .option-title { display:flex; align-items:center; justify-content:space-between; gap:8px; }
    /* compact points badge */
    .scoring-option .points-badge { background:var(--color-surface-alt); color:var(--color-highlight); border:1px solid var(--color-surface-alt); padding:3px 6px 2px; font-size:0.55rem; font-weight:600; letter-spacing:.4px; border-radius:9px; line-height:1; white-space:nowrap; margin-left:auto; }
    .scoring-option .option-desc { margin-top:6px; font-size:0.55rem; letter-spacing:.4px; opacity:.6; line-height:1.25; font-weight:500; }
    .scoring-option .option-points { margin-top:6px; font-size:0.55rem; letter-spacing:.4px; opacity:.65; line-height:1.25; font-weight:500; }

        .winner-selection h3 {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }
    .winner-selection .header-row { display:flex; align-items:center; justify-content:space-between; margin-bottom:12px; }
    .winner-selection .header-row h3 { margin:0; }
    .change-mode-btn { background:var(--color-surface-alt); border:1px solid var(--color-accent); color:#fff; font-size:.55rem; padding:6px 10px; border-radius:8px; cursor:pointer; font-weight:600; letter-spacing:.5px; }
    .change-mode-btn:hover { background:var(--color-surface-strong); }
    .winner-selection .mode-label { font-size:.7rem; font-weight:600; letter-spacing:.5px; color:var(--color-highlight); background:var(--color-surface-alt); padding:6px 10px; border-radius:8px; display:inline-flex; align-items:center; gap:6px; }

        .winner-options {
            display: grid;
            gap: 10px;
        }

    .winner-option { background: var(--color-surface); padding: 12px; border-radius: 10px; cursor: pointer; transition: background .25s ease, border-color .25s ease, transform .25s ease; border: 2px solid transparent; text-align: center; }
    .winner-option:hover { background: var(--color-surface-alt); border-color: var(--color-highlight); }
    .winner-option.selected { background: var(--color-highlight-soft); border-color: var(--color-highlight); }
    .winner-option.tie { background: var(--color-surface-strong); }
    .winner-option.tie:hover { background: var(--color-surface-alt); }
    .winner-option.tie.selected { background: var(--color-highlight-soft); border-color: var(--color-highlight); }

        .navigation {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .utility-actions {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }
    .utility-actions .btn-reset { background: var(--color-surface-alt); font-size: 0.8rem; padding: 10px 12px; letter-spacing: .5px; }
    .utility-actions .btn-reset:hover { background: var(--color-surface-strong); }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.55);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
        }
    .modal { background: var(--color-surface-strong); border: 1px solid var(--color-accent); border-radius: 16px; padding: 20px; max-width: 320px; width: 90%; color: #fff; font-size: 0.95rem; box-shadow: 0 4px 18px rgba(0,0,0,0.4); }
        .modal h3 { margin: 0 0 10px; font-size: 1.05rem; }
        .modal p { margin: 0 0 16px; opacity: 0.85; line-height: 1.3; }
        .modal-actions { display: flex; gap: 10px; }
        .modal-actions button { flex: 1; padding: 10px 12px; font-size: 0.85rem; }
    .btn-danger { background: var(--color-danger); }
    .btn-danger:hover { background: var(--color-danger-hover); }
    .btn-ghost { background: var(--color-surface-alt); }
    .btn-ghost:hover { background: var(--color-surface-strong); }

        .nav-btn {
            flex: 1;
            padding: 12px;
            font-size: 1rem;
        }

        .nav-btn:disabled {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.4);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .nav-btn:disabled:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: none;
        }

        .hidden {
            display: none !important; /* ensure it overrides component display */
        }

    /* Overview panel */
    .overview-overlay { position: fixed; inset:0; background: rgba(0,0,0,0.65); backdrop-filter: blur(6px); z-index: 1200; display: flex; align-items: flex-start; justify-content: center; overflow-y:auto; padding: 50px 12px 40px; }
    .overview-panel { background: var(--color-surface-strong); border:1px solid var(--color-accent); border-radius:18px; width:100%; max-width:900px; padding:18px 20px 26px; box-shadow:0 8px 28px rgba(0,0,0,.55); }
    .overview-header { display:flex; align-items:center; justify-content:space-between; margin-bottom:14px; }
    .overview-title { font-size:1.15rem; font-weight:600; letter-spacing:.5px; color:var(--color-highlight); }
    .overview-close { background:var(--color-surface-alt); border:1px solid var(--color-accent); color:#fff; padding:6px 12px; border-radius:10px; font-size:.75rem; font-weight:600; letter-spacing:.5px; cursor:pointer; }
    .overview-close:hover { background:var(--color-surface-strong); }
    .overview-tools { display:flex; align-items:center; gap:8px; }
    .overview-table-wrapper { overflow-x:hidden; border:1px solid var(--color-surface-alt); border-radius:12px; }
    table.overview-table { width:100%; border-collapse:collapse; font-size:.62rem; table-layout:fixed; }
    table.overview-table th, table.overview-table td { padding:3px 5px; text-align:left; border-bottom:1px solid rgba(255,255,255,0.08); vertical-align:top; }
    table.overview-table th { position:sticky; top:0; background:var(--color-surface-alt); font-weight:600; font-size:.58rem; letter-spacing:.5px; text-transform:uppercase; }
    table.overview-table col.hole { width:34px; }
    table.overview-table col.mode { width:42px; }
    table.overview-table col.wolf { width:58px; }
    table.overview-table col.result { width:auto; }
    table.overview-table tr:last-child td { border-bottom:none; }
    table.overview-table tbody tr { cursor:pointer; transition: background .18s ease; }
    table.overview-table tbody tr:hover { background:rgba(255,255,255,0.07); }
    .ov-hole { font-weight:600; font-variant-numeric: tabular-nums; }
    .ov-mode { white-space:nowrap; }
    .ov-result { color: var(--color-highlight); font-weight:600; line-height:1.1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .ov-wolf { opacity:.75; }
    .no-data { padding:14px 4px; text-align:center; font-size:.8rem; opacity:.7; }
    .current-row { background: var(--color-accent-soft) !important; }
    /* Player overview specific tweaks */
    #playerOverviewOverlay .overview-title { display:flex; align-items:center; gap:8px; }
    #playerOverviewOverlay .player-switch { background:var(--color-surface-alt); border:1px solid var(--color-accent); color:#fff; padding:4px 8px; border-radius:8px; font-size:.55rem; font-weight:600; letter-spacing:.5px; cursor:pointer; }
    #playerOverviewOverlay .player-switch:hover { background:var(--color-surface-strong); }
    #playerOverviewOverlay table.overview-table col.mode { width:48px; }
    #playerOverviewOverlay table.overview-table col.points { width:50px; }
    #playerOverviewOverlay table.overview-table col.cum { width:58px; }
    #playerOverviewOverlay table.overview-table td.points-pos { color: var(--color-highlight); }
    #playerOverviewOverlay table.overview-table td.points-zero { opacity:.45; }
    #playerOverviewOverlay table.overview-table td.cum { font-weight:600; color: var(--color-highlight); }
    #playerOverviewOverlay .small-hint { text-align:right; }
     @media (max-width:700px){
         table.overview-table { font-size:.53rem; }
         table.overview-table th, table.overview-table td { padding:2px 3px; }
         table.overview-table col.mode { width:36px; }
         table.overview-table col.wolf { width:50px; }
     }

    .game-summary { background: var(--color-surface-strong); border-radius: 16px; padding: 22px; backdrop-filter: blur(10px); }

    .summary-title { text-align: center; font-size: 1.45rem; margin-bottom: 18px; color: var(--color-highlight); text-shadow: 0 0 6px var(--color-highlight-soft); }

        .final-scores {
            display: grid;
            gap: 15px;
        }

    .final-player { background: var(--color-surface-alt); padding: 14px 16px; border-radius: 12px; display: flex; justify-content: space-between; align-items: center; border: 1px solid transparent; }
    .final-player.winner { background: var(--color-highlight-soft); border-color: var(--color-highlight); }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.5rem;
            }
            
            .players-grid {
                grid-template-columns: 1fr;
            }
            
            .hole-number {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="header-bar">
                <h1>üê∫ GOLF</h1>
                <div class="current-hole hidden inactive" id="currentHole" role="button" title="Tap for overview" onclick="toggleOverview()"></div>
            </div>
            <div class="scoreboard hidden" id="scoreboard">
                <div class="players-grid" id="playersGrid">
                    <!-- Players will be populated here -->
                </div>
            </div>
        </div>

        <!-- Game Setup -->
        <div class="game-setup" id="gameSetup">
            <div class="setup-section">
                <h3>Number of Players</h3>
                <div class="input-group">
                    <div class="player-count-buttons">
                        <button class="btn btn-player-count" id="player3Btn" onclick="setPlayerCount(3)">3</button>
                        <button class="btn btn-player-count selected" id="player4Btn" onclick="setPlayerCount(4)">4</button>
                    </div>
                </div>
            </div>

            <div class="setup-section">
                <h3>Players</h3>
                <div class="input-group">
                    <input type="text" id="player1" placeholder="Player 1">
                </div>
                <div class="input-group">
                    <input type="text" id="player2" placeholder="Player 2">
                </div>
                <div class="input-group">
                    <input type="text" id="player3" placeholder="Player 3">
                </div>
                <div class="input-group" id="player4Group" style="display:none;">
                    <input type="text" id="player4" placeholder="Player 4">
                </div>
            </div>


            <div class="setup-section">
                <h3>Wolf Rotation</h3>
                <div class="input-group">
                  <div class="player-count-buttons" id="rotationButtons" style="margin-top:4px;">
                    <button type="button" class="btn btn-player-count selected" id="rotationRollingBtn" onclick="setRotationMode('rolling')">Rolling</button>
                    <button type="button" class="btn btn-player-count" id="rotationRandomBtn" onclick="setRotationMode('random')">Random</button>
                  </div>
                  <div style="margin-top:8px; font-size:0.75rem; opacity:.7; line-height:1.3;">Rolling cycles players in order after the first wolf is randomly picked. Random creates a balanced randomized order.</div>
                </div>
              </div>

            <div class="setup-section">
                <div style="display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:6px;">
                    <h3 style="margin:0;">Stakes</h3>
                    <label style="display:flex; align-items:center; gap:6px; font-size:0.65rem; letter-spacing:.5px; text-transform:uppercase; background:var(--color-surface-alt); padding:6px 10px; border-radius:8px; cursor:pointer;">
                        <input type="checkbox" id="bettingEnabled" onchange="toggleBettingInputs()" style="width:16px; height:16px;"> Enable
                    </label>
                </div>
                <div class="input-group" style="display:flex; flex-direction:column; gap:8px;">
                    <div id="stakesAmountRow" style="display:none; flex-direction:column; gap:6px;">
                        <div style="display:flex; align-items:center; gap:12px;">
                            <label for="amountPerPoint" style="font-size:0.6rem; letter-spacing:.5px; text-transform:uppercase; opacity:.75; flex:0 0 90px;">Stake / pt</label>
                            <input type="range" id="amountPerPoint" min="0.05" max="20" step="0.05" value="0.15" disabled oninput="updateStakeSliderDisplay(); updateStakesEstimates();" style="flex:1;">
                            <div id="amountPerPointValue" style="font-size:0.7rem; font-weight:600; letter-spacing:.5px; width:54px; text-align:right;">‚Ç¨0.15</div>
                        </div>
                        <div style="font-size:0.55rem; opacity:.55; line-height:1.2;">Range ‚Ç¨0.05 ‚Äì ‚Ç¨20.00. Adjust to set stakes per point.</div>
                    </div>
                    <div id="stakesEstimatorRow" style="display:none; flex-direction:column; gap:6px; background:var(--color-surface-alt); padding:10px 12px; border-radius:10px;">
                        <div style="display:flex; align-items:center; gap:10px;">
                            <label for="teeWolfFreq" style="font-size:0.6rem; letter-spacing:.5px; text-transform:uppercase; opacity:.75; flex:0 0 110px;">Tee Wolf freq</label>
                            <input type="range" id="teeWolfFreq" min="0" max="100" step="5" value="60" style="flex:1;" oninput="updateStakesEstimates()">
                            <div id="teeWolfFreqLabel" style="font-size:0.6rem; opacity:.7; width:42px; text-align:right;">60%</div>
                        </div>
                        <div id="estimatedMaxLoss" style="font-size:0.7rem; font-weight:600; letter-spacing:.5px; color:var(--color-highlight);">Estimated max loss: ‚Äî</div>
                        <div style="font-size:0.48rem; opacity:.55; margin-top:2px; line-height:1.1;" id="estimateContextNote">3P Tee Wolf cap 4 / Fairway 2. 4P Tee Wolf cap 6 / Fairway 3.</div>
                        <div style="font-size:0.55rem; opacity:.55; line-height:1.15;">Approximate worst-case if many Tee Wolf attempts succeed or fail badly. Adjust slider for aggressiveness. Actual results can vary.</div>
                    </div>
                </div>
            </div>

            <button class="btn" onclick="startGame()">Start Game</button>
        </div>

        <!-- Hole Scoring -->
        <div class="hole-scoring hidden" id="holeScoring">
            <div class="wolf-info">
                <div class="wolf-name" id="wolfName">Wolf for Hole 1: Player 1</div>
            </div>


            <div class="mode-selection">
                <h3>Wolf decision</h3>
                <div class="scoring-options" id="scoringOptions"><!-- Options injected --></div>
            </div>

            <div class="winner-selection hidden" id="winnerSelection">
                <h3>Who won this hole?</h3>
                <div class="winner-options" id="winnerOptions">
                    <!-- Winner options will be populated here -->
                </div>
            </div>

            <div class="navigation">
                <button class="btn nav-btn" onclick="previousHole()" id="prevHoleBtn" disabled>‚Üê Previous</button>
                <button class="btn nav-btn" onclick="nextHole()" id="nextHoleBtn" disabled>Next ‚Üí</button>
            </div>
            <div class="utility-actions">
                <button class="btn btn-reset" type="button" onclick="resetGame()">Reset Game</button>
            </div>
        </div>


        <!-- Game Summary -->
        <div class="game-summary hidden" id="gameSummary">
            <div class="summary-title">Game Complete!</div>
            <div class="final-scores" id="finalScores">
                <!-- Final scores will be populated here -->
            </div>
            <div style="display:flex; gap:10px; margin-top:18px;">
                <button class="btn btn-secondary" type="button" onclick="backToLastHole()">‚Üê Back</button>
                <button class="btn" type="button" onclick="newGame()">New Game</button>
            </div>
        </div>
        <!-- Custom Reset Modal -->
        <div class="modal-overlay hidden" id="resetDialog" role="dialog" aria-modal="true" aria-labelledby="resetTitle">
            <div class="modal">
                <h3 id="resetTitle">Reset Game?</h3>
                <p>This will clear all players, scores and progress. This cannot be undone.</p>
                <div class="modal-actions">
                    <button class="btn btn-danger" type="button" onclick="confirmReset()">Yes, reset</button>
                    <button class="btn btn-ghost" type="button" onclick="cancelReset()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Overview Panel -->
    <div id="overviewOverlay" class="overview-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="overviewTitle">
        <div class="overview-panel">
            <div class="overview-header">
                <div class="overview-title" id="overviewTitle">Hole Overview</div>
                <div class="overview-tools">
                    <button class="overview-close" type="button" onclick="toggleOverview(false)">Close ‚úï</button>
                </div>
            </div>
            <div class="overview-table-wrapper" id="overviewTableWrapper">
                <!-- Table is rendered dynamically -->
            </div>
            <div class="small-hint" style="margin-top:12px; font-size:.55rem; opacity:.55; text-align:right; letter-spacing:.5px;">Tap a row to jump & edit</div>
        </div>
    </div>

    <!-- Player Overview Panel -->
    <div id="playerOverviewOverlay" class="overview-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="playerOverviewTitle">
        <div class="overview-panel">
            <div class="overview-header">
                <div class="overview-title" id="playerOverviewTitle">Player Overview</div>
                <div class="overview-tools" id="playerOverviewTools">
                    <button class="overview-close" type="button" onclick="game.hidePlayerOverview()">Close ‚úï</button>
                </div>
            </div>
            <div class="overview-table-wrapper" id="playerOverviewTableWrapper"></div>
            <div class="small-hint" style="margin-top:12px; font-size:.55rem; opacity:.55; letter-spacing:.5px;">Tap a played hole to jump</div>
        </div>
    </div>

    <script>
        class WolfGame {
            constructor() {
                this.players = [];
                this.currentHole = 1;
                this.totalHoles = 18;
                this.currentWolf = 0;
                this.holeResults = [];
                this.scores = {};
                this.currentHoleResult = null;
                this.stateVersion = 1;
                this.rotationMode = 'rolling';
                this.wolfOrder = [];
                this.wolfPointer = 0;
                this.wolfHistory = []; // holds wolf player indices per hole (including current hole)
                this.currentHoleWinners = null; // winners for currently viewed hole (for highlighting)
                this.lastScores = {}; // transient previous scores for delta animation
                this.bettingEnabled = false;
                this.amountPerPoint = 0;
            }

            initializeGame(playerNames, totalHoles) {
                this.players = playerNames.filter(n => n.trim() !== '');
                this.totalHoles = totalHoles;
                this.currentHole = 1;
                                if (this.rotationMode === 'rolling') {
                                    // Secure/randomized first wolf selection
                                    const n = this.players.length;
                                    if (n > 0) {
                                        try {
                                            const arr = new Uint32Array(1);
                                            crypto.getRandomValues(arr);
                                            this.currentWolf = arr[0] % n;
                                        } catch(e) {
                                            this.currentWolf = Math.floor(Math.random() * n); // fallback
                                        }
                                    } else {
                                        this.currentWolf = 0;
                                    }
                  this.wolfOrder = [];
                  this.wolfPointer = 0;
                } else {
                  this.buildRandomWolfOrder();
                  this.wolfPointer = 0;
                  this.currentWolf = this.wolfOrder[0];
                }
                // initialize wolf history with first hole's wolf
                this.wolfHistory = [this.currentWolf];
                this.holeResults = [];
                this.scores = {};
                this.currentHoleResult = null;
                this.players.forEach(p => this.scores[p] = 0);
                // betting config (capture current UI values)
                const betChk = document.getElementById('bettingEnabled');
                const amtInput = document.getElementById('amountPerPoint');
                if (betChk) this.bettingEnabled = betChk.checked; else this.bettingEnabled = false;
                if (this.bettingEnabled && amtInput) this.amountPerPoint = parseFloat(amtInput.value)||0; else this.amountPerPoint = 0;
                this.updateScoreboard();
                this.showHoleScoring();
                this.saveState();
            }

            updateScoreboard() {
                const playersGrid = document.getElementById('playersGrid');
                const scoreboard = document.getElementById('scoreboard');
                playersGrid.innerHTML = '';
                const prev = { ...this.lastScores };
                if (this.players.length === 0) { 
                    scoreboard.classList.add('hidden');
                } else {
                    // Refresh betting configuration from UI elements in case they changed
                    this.refreshBettingConfig();
                    let moneyNet = null;
                    if (this.bettingEnabled && this.amountPerPoint > 0) {
                        moneyNet = this.computeMoneyNet();
                    }
                    // Medal ranking calculation removed from live scoreboard for space; medals shown only in final summary.
                    // Count wolf occurrences from history
                    const counts = {};
                    this.players.forEach(p => counts[p] = 0);
                    this.wolfHistory.forEach(idx => {
                        const name = this.players[idx];
                        if (name !== undefined) counts[name]++;
                    });
                    this.players.forEach(player => {
                        const playerCard = document.createElement('div');
                        playerCard.className = 'player-card';
                        playerCard.dataset.player = player;
                        const score = this.scores[player] || 0;
                        const wolfCount = counts[player] || 0;
                        const deltaVal = (prev[player] !== undefined) ? (score - (prev[player]||0)) : 0;
                        const bumpClass = deltaVal !== 0 ? ' bump' : '';
                        playerCard.title = `${player}: ${score} pts, Wolf ${wolfCount}x`;
                        const moneyStr = (moneyNet && (moneyNet[player] || moneyNet[player]===0)) ? `<span class=\"money-value\">‚Ç¨${this.formatMoney(moneyNet[player])}</span>` : '';
                        playerCard.innerHTML = `
                            <div class=\"player-name\">${player}</div>
                            <div class=\"player-score\"><span class=\"score-value${bumpClass}\">${score}</span><span class=\"wolf-count\">(${wolfCount})</span>${moneyStr}</div>
                        `;
                        playerCard.addEventListener('click', () => this.showPlayerOverview(player));
                        playersGrid.appendChild(playerCard);
                    });
                    scoreboard.classList.remove('hidden');
                }
                // update lastScores snapshot
                this.lastScores = {};
                this.players.forEach(p=> this.lastScores[p] = this.scores[p] || 0);
                this.saveState();
            }

            showHoleScoring() {
                // Always hide overview if visible when returning to scoring UI
                const ov = document.getElementById('overviewOverlay');
                if (ov && !ov.classList.contains('hidden')) ov.classList.add('hidden');
                document.getElementById('gameSetup').classList.add('hidden');
                document.getElementById('holeScoring').classList.remove('hidden');
                document.getElementById('gameSummary').classList.add('hidden');
                document.getElementById('winnerSelection').classList.add('hidden');

                const wolfName = document.getElementById('wolfName');
                const currentHole = document.getElementById('currentHole');

                const wolfPlayer = this.players[this.currentWolf];
                wolfName.innerHTML = `Wolf for Hole ${this.currentHole}: <span class="wolf-player">${wolfPlayer}</span>`;
                if (currentHole) { currentHole.classList.remove('hidden','inactive'); currentHole.textContent = `${this.currentHole}/${this.totalHoles}`; }

                this.updateNavigationButtons();
                // Restore state for this hole if it exists
                this.restoreCurrentHoleSelection();
                this.populateScoringOptions();
                this.highlightSelectedOption && this.highlightSelectedOption();
                const modeSection = document.querySelector('.mode-selection');
                if (this.currentHoleResult) {
                    if (modeSection) modeSection.classList.add('hidden');
                    this.showWinnerSelection(true);
                } else if (modeSection) {
                    modeSection.classList.remove('hidden');
                }
                this.updateScoreboard();
                this.scrollToTop();
            }

            scrollToTop() {
                // Defer to next frame to ensure layout is settled
                if (typeof window !== 'undefined') {
                    requestAnimationFrame(() => {
                        try {
                            window.scrollTo({ top: 0, behavior: 'instant' });
                        } catch(e) {
                            // Fallback for browsers without 'instant'
                            window.scrollTo(0,0);
                        }
                    });
                }
            }

            refreshBettingConfig() {
                // Update betting configuration from current UI state
                const betChk = document.getElementById('bettingEnabled');
                const amtInput = document.getElementById('amountPerPoint');
                if (betChk) this.bettingEnabled = betChk.checked; else this.bettingEnabled = false;
                if (this.bettingEnabled && amtInput) this.amountPerPoint = parseFloat(amtInput.value)||0; else this.amountPerPoint = 0;
            }

            /* Player Overview Feature */
            showPlayerOverview(player) {
                // Hide general overview if open
                const ov = document.getElementById('overviewOverlay');
                if (ov && !ov.classList.contains('hidden')) ov.classList.add('hidden');
                const overlay = document.getElementById('playerOverviewOverlay');
                if (!overlay) return;
                // Build table
                this.buildPlayerOverviewTable(player);
                // Title & nav
                const titleEl = document.getElementById('playerOverviewTitle');
                if (titleEl) titleEl.innerHTML = `Player: <span style="color:var(--color-highlight);">${player}</span>`;
                this.injectPlayerSwitcher(player);
                overlay.classList.remove('hidden');
                // Trap simple ESC
                if (!this._playerEscHandler) {
                    this._playerEscHandler = (e) => { if (e.key === 'Escape') this.hidePlayerOverview(); };
                    document.addEventListener('keydown', this._playerEscHandler);
                }
            }

            hidePlayerOverview() {
                const overlay = document.getElementById('playerOverviewOverlay');
                if (overlay) overlay.classList.add('hidden');
                if (this._playerEscHandler) {
                    document.removeEventListener('keydown', this._playerEscHandler);
                    this._playerEscHandler = null;
                }
            }

            injectPlayerSwitcher(current) {
                const tools = document.getElementById('playerOverviewTools');
                if (!tools) return;
                // Remove existing switches except close
                [...tools.querySelectorAll('.player-switch')].forEach(b=>b.remove());
                if (this.players.length <= 1) return;
                const idx = this.players.indexOf(current);
                const prevIdx = (idx - 1 + this.players.length) % this.players.length;
                const nextIdx = (idx + 1) % this.players.length;
                const prevBtn = document.createElement('button');
                prevBtn.type = 'button';
                prevBtn.className = 'player-switch';
                prevBtn.textContent = `‚Üê ${this.players[prevIdx]}`;
                prevBtn.onclick = () => this.showPlayerOverview(this.players[prevIdx]);
                const nextBtn = document.createElement('button');
                nextBtn.type = 'button';
                nextBtn.className = 'player-switch';
                nextBtn.textContent = `${this.players[nextIdx]} ‚Üí`;
                nextBtn.onclick = () => this.showPlayerOverview(this.players[nextIdx]);
                tools.insertBefore(prevBtn, tools.firstChild);
                tools.appendChild(nextBtn);
            }

            buildPlayerOverviewTable(player) {
                const wrap = document.getElementById('playerOverviewTableWrapper');
                if (!wrap) return;
                const total = this.totalHoles;
                let cumulative = 0;
                // Determine how many holes have assigned wolves (visited holes)
                const visitedHoles = this.wolfHistory.length; // holes with known wolf
                const rows = [];
                rows.push(`<table class="overview-table player-table"><colgroup><col class="hole"><col class="mode"><col class="points"><col class="cum"></colgroup><thead><tr><th>H</th><th>M</th><th>Pts</th><th>Cum</th></tr></thead><tbody>`);
                for (let h=1; h<= total; h++) {
                    const rec = this.holeResults.find(r=>r.hole===h);
                    let pts = 0;
                    let mode = '';
                    if (rec) {
                        pts = rec.pointsAwarded[player] || 0;
                        mode = this.abbrevMode(rec.result, player);
                    } else if (h <= visitedHoles) {
                        // visited but not scored yet
                        const wolfIdx = this.wolfHistory[h-1];
                        const res = (h === this.currentHole) ? this.currentHoleResult : null;
                        mode = res ? this.abbrevMode(res, player) : (this.players[wolfIdx] === player ? '‚ÄîW' : '‚Äî');
                    } else {
                        mode = '¬∑';
                    }
                    cumulative += pts;
                    const clickable = h <= visitedHoles; // only allow jump to visited holes
                    rows.push(`<tr data-hole="${h}" class="${h===this.currentHole?'current-row':''} ${clickable?'clickable-row':''}" style="${clickable?'cursor:pointer;':''}">`+
                        `<td class="ov-hole">${h}</td>`+
                        `<td class="ov-mode">${mode}</td>`+
                        `<td class="${pts>0?'points-pos':'points-zero'}">${pts>0?('+'+pts):pts}</td>`+
                        `<td class="cum">${cumulative}</td>`+
                        `</tr>`);
                }
                rows.push('</tbody></table>');
                wrap.innerHTML = rows.join('');
                // Attach row click
                wrap.querySelectorAll('tr.clickable-row').forEach(tr => {
                    tr.addEventListener('click', () => {
                        const hole = parseInt(tr.getAttribute('data-hole'),10);
                        this.goToHole(hole);
                        this.hidePlayerOverview();
                    });
                });
            }

            abbrevMode(result, player) {
                if (!result) return '';
                const t = result.type;
                if (t === 'lone-wolf') return 'Tee';
                if (t === 'wolf-solo') return 'Fair';
                if (t === 'wolf-partner') {
                    const partner = result.partner;
                    if (result.wolf === player || partner === player) return 'P‚úì';
                    return 'P';
                }
                return '';
            }

            goToHole(target) {
                if (target < 1 || target > this.totalHoles) return;
                // Ensure wolf history filled up to target (generate using existing nextHole logic without scoring)
                while (this.wolfHistory.length < target) {
                    // Simulate wolf rotation without advancing scores
                    if (this.rotationMode === 'rolling') {
                        const lastWolfIdx = this.wolfHistory[this.wolfHistory.length - 1];
                        const nextWolfIdx = (lastWolfIdx + 1) % this.players.length;
                        this.wolfHistory.push(nextWolfIdx);
                    } else {
                        // random mode uses precomputed order
                        if (this.wolfOrder.length === 0) { this.buildRandomWolfOrder(); }
                        if (this.wolfHistory.length < this.wolfOrder.length) {
                            this.wolfHistory.push(this.wolfOrder[this.wolfHistory.length]);
                        } else {
                            // rebuild if exhausted (shouldn't usually happen)
                            this.buildRandomWolfOrder();
                            this.wolfHistory.push(this.wolfOrder[this.wolfHistory.length]);
                        }
                    }
                }
                this.currentHole = target;
                this.currentWolf = this.wolfHistory[target-1] || 0;
                this.restoreCurrentHoleSelection();
                this.showHoleScoring();
            }
                restoreCurrentHoleSelection() {
                    const match = this.holeResults.find(hr => hr.hole === this.currentHole);
                    if (match) {
                        this.currentHoleResult = match.result;
                        this.currentHoleWinners = match.winners || null;
                    } else {
                        this.currentHoleResult = null;
                        this.currentHoleWinners = null;
                    }
                }

                highlightSelectedWinners() {
                    if (!this.currentHoleWinners || !this.currentHoleWinners.length) return;
                    const winners = this.currentHoleWinners;
                    // Tie case
                    if (winners.length === 0) {
                        const tie = document.querySelector('#winnerOptions .winner-option.tie');
                        if (tie) tie.classList.add('selected');
                        return;
                    }
                    const normalized = winners.slice().sort().join('|');
                    document.querySelectorAll('#winnerOptions .winner-option').forEach(opt => {
                        const text = opt.textContent;
                        // Build candidate arrays from option text
                        let candidate = [];
                        if (text.includes('(Wolf Team)')) {
                            candidate = text.replace('(Wolf Team)','').split('+').map(s=>s.replace(/[^A-Za-z0-9 ]/g,'').trim()).filter(Boolean);
                        } else if (text.includes('(Opponent Team)')) {
                            candidate = text.replace('(Opponent Team)','').split('+').map(s=>s.replace(/[^A-Za-z0-9 ]/g,'').trim()).filter(Boolean);
                        } else if (text.includes('(Wolf)')) {
                            candidate = [text.replace('(Wolf)','').trim()];
                        } else if (text.includes('(Opponents)')) {
                            candidate = text.replace('(Opponents)','').split('+').map(s=>s.replace(/[^A-Za-z0-9 ]/g,'').trim()).filter(Boolean);
                        }
                        const candKey = candidate.slice().sort().join('|');
                        if (candKey === normalized) {
                            opt.classList.add('selected');
                        }
                    });
                }

                highlightSelectedOption() {
                    if (!this.currentHoleResult) return;
                    const { type, partner } = this.currentHoleResult;
                    // Prefer data attributes for precise matching
                    let selector = `#scoringOptions .scoring-option[data-mode="${type}"]`;
                    if (type === 'wolf-partner' && partner) selector += `[data-partner="${partner}"]`;
                    document.querySelectorAll('#scoringOptions .scoring-option').forEach(o=>o.classList.remove('selected'));
                    const el = document.querySelector(selector);
                    if (el) el.classList.add('selected');
                }

            populateScoringOptions() {
                const scoringOptions = document.getElementById('scoringOptions');
                scoringOptions.innerHTML = '';

                const wolfName = this.players[this.currentWolf];
                const otherPlayers = this.players.filter((_, index) => index !== this.currentWolf);

                const opponentsCount = otherPlayers.length;
                                const compactBadge = (mode) => {
                                        const fourP = this.players.length === 4;
                                        // Always show Wolf side per-player win value (or Wolf team member) / Opponent side per-player win value.
                                        if (mode === 'lone-wolf') {
                                                return fourP
                                                    ? '<span class="points-badge" title="Tee Wolf: Wolf wins 6; each opponent wins 2 if they beat Wolf">6P / 2P</span>'
                                                    : '<span class="points-badge" title="Tee Wolf: Wolf wins 4; each opponent wins 2 if they beat Wolf">4P / 2P</span>';
                                        }
                                        if (mode === 'wolf-solo') {
                                                return fourP
                                                    ? '<span class="points-badge" title="Fairway Wolf: Wolf (or single opponent) wins 3; if field wins they get 1 each">3P / 1P</span>'
                                                    : '<span class="points-badge" title="Fairway Wolf: Wolf (or single opponent) wins 2; field win 1 each">2P / 1P</span>';
                                        }
                                        if (mode === 'wolf-partner') {
                                                return fourP
                                                    ? '<span class="points-badge" title="Partner 4P: Wolf team member wins 1; opponent team member wins 1">1P / 1P</span>'
                                                    : '<span class="points-badge" title="Partner 3P: Wolf team member wins 1; lone opponent wins 2">1P / 2P</span>';
                                        }
                                        return '';
                                };

                if (this.players.length === 3) {
                    // 3 players: Tee Wolf, Fairway Wolf, then partner options
                        const superWolfOption = document.createElement('div');
                        superWolfOption.className = 'scoring-option';
                        superWolfOption.dataset.mode = 'lone-wolf';
                        superWolfOption.innerHTML = `<div class=\"option-title\">üî• Tee Wolf ${compactBadge('lone-wolf')}</div><div class=\"option-desc\">Declared on the tee before any shots. Wolf plays alone for ${this.players.length===4? '6':'4'} points.</div>`;
                        superWolfOption.onclick = () => this.selectScoringOption('lone-wolf');
                        scoringOptions.appendChild(superWolfOption);

                    const soloOption = document.createElement('div');
                    soloOption.className = 'scoring-option';
                    soloOption.dataset.mode = 'wolf-solo';
                        soloOption.innerHTML = `<div class=\"option-title\">üê∫ Fairway Wolf ${compactBadge('wolf-solo')}</div><div class=\"option-desc\">Chosen after tee shots (before 2nd shots). Solo vs field for ${this.players.length===4? '3':'2'} points.</div>`;
                    soloOption.onclick = () => this.selectScoringOption('wolf-solo');
                    scoringOptions.appendChild(soloOption);

                    otherPlayers.forEach(partner => {
                        const partnerOption = document.createElement('div');
                        partnerOption.className = 'scoring-option';
                        partnerOption.dataset.mode = 'wolf-partner';
                        partnerOption.dataset.partner = partner;
                            partnerOption.innerHTML = `<div class=\"option-title\">ü§ù Wolf & ${partner} ${compactBadge('wolf-partner')}</div><div class=\"option-desc\">Wolf picks partner after tee shots (3-player: 2v1). Team +1 each; lone opponent +2.</div>`;
                        partnerOption.onclick = () => this.selectScoringOption('wolf-partner', partner);
                        scoringOptions.appendChild(partnerOption);
                    });
                } else {
                    // 4 players
                    const superWolfOption = document.createElement('div');
                    superWolfOption.className = 'scoring-option';
                    superWolfOption.dataset.mode = 'lone-wolf';
                        superWolfOption.innerHTML = `<div class=\"option-title\">üî• Tee Wolf ${compactBadge('lone-wolf')}</div><div class=\"option-desc\">Declared on the tee before any shots. Wolf plays alone for 6 points.</div>`;
                    superWolfOption.onclick = () => this.selectScoringOption('lone-wolf');
                    scoringOptions.appendChild(superWolfOption);

                    const soloOption = document.createElement('div');
                    soloOption.className = 'scoring-option';
                    soloOption.dataset.mode = 'wolf-solo';
                        soloOption.innerHTML = `<div class=\"option-title\">üê∫ Fairway Wolf ${compactBadge('wolf-solo')}</div><div class=\"option-desc\">Chosen after tee shots (before 2nd shots). Solo vs field for 3 points.</div>`;
                    soloOption.onclick = () => this.selectScoringOption('wolf-solo');
                    scoringOptions.appendChild(soloOption);

                    otherPlayers.forEach(partner => {
                        const partnerOption = document.createElement('div');
                        partnerOption.className = 'scoring-option';
                        partnerOption.dataset.mode = 'wolf-partner';
                        partnerOption.dataset.partner = partner;
                            partnerOption.innerHTML = `<div class=\"option-title\">ü§ù Wolf & ${partner} ${compactBadge('wolf-partner')}</div><div class=\"option-desc\">Wolf picks partner after tee shots. Two vs Two. Winning team +1 each.</div>`;
                        partnerOption.onclick = () => this.selectScoringOption('wolf-partner', partner);
                        scoringOptions.appendChild(partnerOption);
                    });
                }
            }

            selectScoringOption(optionType, partner = null) {
                // Clear previous selections
                        document.querySelectorAll('.scoring-option').forEach(o => o.classList.remove('selected'));
                        const clicked = event.target.closest('.scoring-option');
                        if (clicked) clicked.classList.add('selected');
                        const wolfName = this.players[this.currentWolf];
                        let result = null;
                        if (optionType === 'wolf-solo') {
                            result = { type: 'wolf-solo', wolf: wolfName, opponents: this.players.filter((_, i) => i !== this.currentWolf) };
                        } else if (optionType === 'lone-wolf') {
                            result = { type: 'lone-wolf', wolf: wolfName, opponents: this.players.filter((_, i) => i !== this.currentWolf) };
                        } else if (optionType === 'wolf-partner') {
                            const opponents = this.players.filter(p => p !== wolfName && p !== partner);
                            result = { type: 'wolf-partner', wolf: wolfName, partner, opponents };
                        }
                        this.currentHoleResult = result;
                        const existingIdx = this.holeResults.findIndex(hr => hr.hole === this.currentHole);
                        if (existingIdx >= 0) {
                            this.holeResults[existingIdx].result = result;
                            this.holeResults[existingIdx].winners = [];
                            this.currentHoleWinners = null;
                            this.recalculateScores();
                            this.updateScoreboard();
                            this.showWinnerSelection(true);
                        } else {
                            this.showWinnerSelection(false);
                        }
                        // Hide mode selection for snappier feel
                        const modeSection = document.querySelector('.mode-selection');
                        if (modeSection) modeSection.classList.add('hidden');
                        this.saveState();
            }

            recordHoleResult(winners) {
                if (!this.currentHoleResult) return;

                const result = this.currentHoleResult;
                let pointsAwarded = {};

                // Pot size is 1 point baseline for all modes now.
                // Scoring rules (pot=1):
                // wolf-partner:
                //    3 players (2v1): Wolf team win -> each 1. Lone opponent win -> 2.
                //    4 players (2v2): Winning team -> each 1 (no lone opponent outcome).
                // wolf-solo (Fairway Wolf):
                //    3 players: Wolf win 2. Single opponent win 2. Opponent pair win 1 each.
                //    4 players: Wolf win 3. Single opponent win 3. Opponent group (>=2) win 1 each.
                // lone-wolf (Tee Wolf):
                //    3 players: Wolf win 4. Single opponent win 4. Opponent pair win 2 each.
                //    4 players: Wolf win 6. Single opponent win 6. Opponent group (>=2) win 2 each.
                if (result.type === 'wolf-solo') {
                    const fourP = this.players.length === 4;
                    const wolfWin = fourP ? 3 : 2;
                    if (winners.includes(result.wolf)) {
                        pointsAwarded[result.wolf] = wolfWin;
                    } else if (winners.length === 1 && result.opponents.includes(winners[0])) {
                        // Single opponent beats wolf (mirrors wolf value)
                        pointsAwarded[winners[0]] = wolfWin;
                    } else {
                        // Opponent group win -> 1 each
                        result.opponents.forEach(o => pointsAwarded[o] = 1);
                    }
                } else if (result.type === 'lone-wolf') {
                    const fourP = this.players.length === 4;
                    const wolfWin = fourP ? 6 : 4;
                    const opponentTeamValue = fourP ? 2 : 2; // unchanged per-opponent baseline in both sizes
                    if (winners.includes(result.wolf)) {
                        pointsAwarded[result.wolf] = wolfWin;
                    } else if (winners.length === 1 && result.opponents.includes(winners[0])) {
                        // Single opponent beats wolf gets full wolf value
                        pointsAwarded[winners[0]] = wolfWin;
                    } else {
                        // Opponent group win: each gets 2 (both 3p and 4p keep 2 each)
                        result.opponents.forEach(o => pointsAwarded[o] = opponentTeamValue);
                    }
                } else if (result.type === 'wolf-partner') {
                    const wolfTeam = [result.wolf, result.partner];
                    const opponentTeam = result.opponents;

                    if (winners.some(w => wolfTeam.includes(w))) {
                        // Wolf+Partner win: Both get pot (pot=1)
                        wolfTeam.forEach(player => {
                            pointsAwarded[player] = 1;
                        });
                    } else if (winners.length === 1 && opponentTeam.includes(winners[0]) && opponentTeam.length === 1) {
                        // 3-player only: lone opponent beats Wolf+Partner gets 2 points
                        pointsAwarded[winners[0]] = 2;
                    } else {
                        // Opponent team wins: Each gets pot (pot=1)
                        opponentTeam.forEach(player => {
                            pointsAwarded[player] = 1;
                        });
                    }
                }

                // Tie: No points
                if (winners.length === 0) {
                    pointsAwarded = {};
                }

                // Update scores
                Object.keys(pointsAwarded).forEach(player => {
                    this.scores[player] += pointsAwarded[player];
                });

                // Store hole result
                this.holeResults.push({
                    hole: this.currentHole,
                    result: result,
                    winners: winners,
                    pointsAwarded: pointsAwarded
                });

                this.updateScoreboard();
                this.saveState();
            }

            nextHole() {
                if (this.currentHole < this.totalHoles) {
                    this.currentHole++;
                    if (this.rotationMode === 'rolling') {
                      this.currentWolf = (this.currentWolf + 1) % this.players.length;
                    } else {
                      if (this.wolfPointer < this.wolfOrder.length - 1) {
                        this.wolfPointer++;
                        this.currentWolf = this.wolfOrder[this.wolfPointer];
                      }
                    }
                    // Record wolf only if advancing to a brand new hole
                    if (this.wolfHistory.length < this.currentHole) {
                        this.wolfHistory.push(this.currentWolf);
                    }
                    this.currentHoleResult = null;
                    this.currentHoleWinners = null;
                    this.updateNavigationButtons();
                    this.showHoleScoring();
                } else {
                    // Check if we're at hole 18 and all holes are completed
                    const allHolesCompleted = this.holeResults.length >= this.totalHoles;
                    if (allHolesCompleted) {
                        this.showGameSummary();
                    }
                }
                this.saveState();
            }

            previousHole() {
                if (this.currentHole > 1) {
                    // remove last hole's wolf entry
                    if (this.wolfHistory.length === this.currentHole) {
                        this.wolfHistory.pop();
                    }
                    this.currentHole--;
                    if (this.rotationMode === 'rolling') {
                        this.currentWolf = this.wolfHistory[this.wolfHistory.length - 1];
                    } else {
                        if (this.wolfPointer > 0) this.wolfPointer--;
                        this.currentWolf = this.wolfHistory[this.wolfHistory.length - 1];
                    }
                    // We'll restore result for this hole in showHoleScoring
                    this.currentHoleResult = null;
                    this.currentHoleWinners = null;
                    this.updateNavigationButtons();
                    this.showHoleScoring(); // This already calls updateScoreboard() which includes money calculations
                }
                this.saveState();
            }

            updateNavigationButtons() {
                const prevBtn = document.getElementById('prevHoleBtn');
                const nextBtn = document.getElementById('nextHoleBtn');
                
                // Update previous button
                prevBtn.disabled = this.currentHole <= 1;
                
                // Update next button - allow going to summary from hole 18 if all holes are completed
                const allHolesCompleted = this.holeResults.length >= this.totalHoles;
                if (this.currentHole >= this.totalHoles && allHolesCompleted) {
                    nextBtn.disabled = false;
                    nextBtn.textContent = 'Summary ‚Üí';
                } else {
                    nextBtn.disabled = this.currentHole >= this.totalHoles;
                    nextBtn.textContent = 'Next ‚Üí';
                }
            }

            showWinnerSelection(editing = false) {
                const result = this.currentHoleResult;
                if (!result) return;
                const winnerOptions = document.getElementById('winnerOptions');
                const winnerSelection = document.getElementById('winnerSelection');
                winnerOptions.innerHTML = '';
                winnerSelection.classList.remove('hidden');
                // Inject header row with change mode button
                if (!winnerSelection.querySelector('.header-row')) {
                    const hdr = document.createElement('div');
                    hdr.className = 'header-row';
                    hdr.innerHTML = `<div class="mode-label">Mode</div><button type="button" class="change-mode-btn" onclick="showModeSelection()">Change Mode</button>`;
                    winnerSelection.prepend(hdr);
                }
                const modeLabelEl = winnerSelection.querySelector('.mode-label');
                if (modeLabelEl) {
                    const icon = this.modeIcon(result);
                    modeLabelEl.textContent = `${icon} ${this.describeMode(result)}`;
                }

                // Tie option first
                const tieOption = document.createElement('div');
                tieOption.className = 'winner-option tie';
                tieOption.innerHTML = 'Tie (No winners)';
                tieOption.onclick = () => this.selectWinner([]);
                winnerOptions.appendChild(tieOption);

                if (result.type === 'wolf-solo' || result.type === 'lone-wolf') {
                    const wolfOption = document.createElement('div');
                    wolfOption.className = 'winner-option';
                    wolfOption.innerHTML = `${result.wolf} (Wolf)`;
                    wolfOption.onclick = () => this.selectWinner([result.wolf]);
                    winnerOptions.appendChild(wolfOption);

                    const opponentsOption = document.createElement('div');
                    opponentsOption.className = 'winner-option';
                    opponentsOption.innerHTML = `${result.opponents.join(' + ')} (Opponents)`;
                    opponentsOption.onclick = () => this.selectWinner(result.opponents);
                    winnerOptions.appendChild(opponentsOption);
                } else if (result.type === 'wolf-partner') {
                    const wolfTeamOption = document.createElement('div');
                    wolfTeamOption.className = 'winner-option';
                    wolfTeamOption.innerHTML = `${result.wolf} + ${result.partner} (Wolf Team)`;
                    wolfTeamOption.onclick = () => this.selectWinner([result.wolf, result.partner]);
                    winnerOptions.appendChild(wolfTeamOption);

                    const opponentTeamOption = document.createElement('div');
                    opponentTeamOption.className = 'winner-option';
                    opponentTeamOption.innerHTML = `${result.opponents.join(' + ')} (Opponent Team)`;
                    opponentTeamOption.onclick = () => this.selectWinner(result.opponents);
                    winnerOptions.appendChild(opponentTeamOption);
                }

                if (editing || this.currentHoleWinners !== null) {
                    this.highlightSelectedWinners();
                }
            }

            selectWinner(winners) {
                document.querySelectorAll('.winner-option').forEach(o => o.classList.remove('selected'));
                if (event && event.target) event.target.classList.add('selected');
                const existingIdx = this.holeResults.findIndex(hr => hr.hole === this.currentHole);
                if (existingIdx >= 0) {
                    this.holeResults[existingIdx].winners = winners;
                    this.currentHoleWinners = winners;
                    this.recalculateScores();
                    this.updateScoreboard();
                    this.saveState();
                } else {
                    this.recordHoleResult(winners);
                    this.currentHoleWinners = winners;
                    this.updateNavigationButtons();
                    this.saveState();
                    // Auto-advance (newly scored hole only)
                    const winnerSelection = document.getElementById('winnerSelection');
                    if (winnerSelection) winnerSelection.classList.add('hidden');
                    // Faster auto-advance for snappier feel
                    if (this.currentHole < this.totalHoles) {
                        setTimeout(()=> this.nextHole(), 250);
                    } else {
                        setTimeout(()=> this.showGameSummary(), 250);
                    }
                }
                // Stay on hole if editing; auto-advance handled above for new holes only
            }
            recalculateScores() {
                const rebuilt = {};
                this.players.forEach(p => rebuilt[p] = 0);
                this.holeResults.sort((a,b)=>a.hole-b.hole).forEach(entry => {
                    const { result, winners } = entry;
                    if (!result || !winners) return;
                    let pts = {};
                    if (result.type === 'wolf-solo') {
                        const fourP = this.players.length === 4;
                        const wolfWin = fourP ? 3 : 2;
                        if (winners.includes(result.wolf)) {
                            pts[result.wolf] = wolfWin;
                        } else if (winners.length === 1 && result.opponents.includes(winners[0])) {
                            pts[winners[0]] = wolfWin;
                        } else if (winners.length > 1) {
                            result.opponents.forEach(o => pts[o] = 1);
                        }
                    } else if (result.type === 'lone-wolf') {
                        const fourP = this.players.length === 4;
                        const wolfWin = fourP ? 6 : 4;
                        if (winners.includes(result.wolf)) {
                            pts[result.wolf] = wolfWin;
                        } else if (winners.length === 1 && result.opponents.includes(winners[0])) {
                            pts[winners[0]] = wolfWin;
                        } else if (winners.length > 1) {
                            result.opponents.forEach(o => pts[o] = 2);
                        }
                    } else if (result.type === 'wolf-partner') {
                        const wolfTeam = [result.wolf, result.partner];
                        const opponentTeam = result.opponents;
                        if (winners.some(w => wolfTeam.includes(w))) {
                            wolfTeam.forEach(p => pts[p] = 1);
                        } else if (winners.length === 1 && opponentTeam.includes(winners[0]) && opponentTeam.length === 1) {
                            // 3-player only lone opponent outcome
                            pts[winners[0]] = 2;
                        } else if (winners.length > 1) {
                            opponentTeam.forEach(p => pts[p] = 1);
                        }
                    }
                    Object.keys(pts).forEach(p => rebuilt[p] += pts[p]);
                });
                this.scores = rebuilt;
                // Update scoreboard with new money calculations when scores are recalculated
                this.updateScoreboard();
            }

            describeMode(result){
                if (!result) return '';
                if (result.type === 'lone-wolf') return 'Tee Wolf';
                if (result.type === 'wolf-solo') return 'Fairway Wolf';
                if (result.type === 'wolf-partner') return `Wolf & ${result.partner}`;
                return result.type;
            }

            modeIcon(result){
                if (!result) return '‚Äî';
                switch(result.type){
                    case 'lone-wolf': return 'üî•';
                    case 'wolf-solo': return 'üê∫';
                    case 'wolf-partner': return 'ü§ù';
                    default: return '‚Äî';
                }
            }

            buildOverviewTableHtml(){
                const rows = [];
                for (let h=1; h<=this.totalHoles; h++) {
                    const hr = this.holeResults.find(r=>r.hole===h);
                    if (!hr) {
                        rows.push(`<tr data-hole="${h}"><td class="ov-hole">${h}</td><td class="ov-mode">‚Äî</td><td class="ov-wolf">${this.wolfHistory[h-1]!==undefined? this.players[this.wolfHistory[h-1]] || '' : ''}</td><td class="ov-result">‚Äî</td></tr>`);
                    } else {
                        const { result, winners, pointsAwarded } = hr;
                        const mode = this.describeMode(result);
                        const wolf = result.wolf;
                        const winnersLabel = (winners && winners.length) ? winners.join(' + ') : '‚Äî';
                        const ptsSummary = Object.keys(pointsAwarded).length ? Object.entries(pointsAwarded).map(([p,v])=>`${p} (+${v})`).join(', ') : '';
                        const combined = ptsSummary ? ptsSummary : winnersLabel;
                        const active = (h === this.currentHole) ? 'current-row' : '';
                        const icon = this.modeIcon(result);
                        rows.push(`<tr class="${active}" data-hole="${h}"><td class="ov-hole">${h}</td><td class="ov-mode" title="${mode}">${icon}</td><td class="ov-wolf">${wolf}</td><td class="ov-result">${combined}</td></tr>`);
                    }
                }
                return `<table class="overview-table" aria-label="Hole overview"><colgroup><col class="hole"><col class="mode"><col class="wolf"><col class="result"></colgroup><thead><tr><th>Hole</th><th>Mode</th><th>Wolf</th><th>Result</th></tr></thead><tbody>${rows.join('')}</tbody></table>`;
            }

            renderOverview(){
                const wrapper = document.getElementById('overviewTableWrapper');
                if (!wrapper) return;
                wrapper.innerHTML = this.buildOverviewTableHtml();
                wrapper.querySelectorAll('tbody tr[data-hole]').forEach(tr => {
                    tr.addEventListener('click', () => {
                        const hole = parseInt(tr.getAttribute('data-hole'),10);
                        if (!isNaN(hole)) this.jumpToHole(hole);
                        toggleOverview(false);
                    });
                });
            }

            jumpToHole(hole){
                if (hole < 1 || hole > this.totalHoles) return;
                this.currentHole = hole;
                // Restore wolf from history/order
                if (this.rotationMode === 'rolling') {
                    if (this.wolfHistory[hole-1] !== undefined) this.currentWolf = this.wolfHistory[hole-1];
                } else if (this.wolfOrder && this.wolfOrder.length >= hole) {
                    this.wolfPointer = hole - 1;
                    this.currentWolf = this.wolfOrder[this.wolfPointer];
                }
                this.showHoleScoring();
            }


            showGameSummary() {
                document.getElementById('holeScoring').classList.add('hidden');
                document.getElementById('gameSummary').classList.remove('hidden');
                this.scrollToTop();

                const finalScores = document.getElementById('finalScores');
                finalScores.innerHTML = '';

                // Sort players by score
                const sortedPlayers = Object.entries(this.scores)
                    .sort(([,a], [,b]) => b - a);
                // Medal mapping with ties
                const medalMap = {};
                if (sortedPlayers.length) {
                    let lastScore = null;
                    let displayedRank = 0;
                    let idx = 0;
                    sortedPlayers.forEach(([p,s]) => {
                        idx++;
                        if (s !== lastScore) { displayedRank = idx; lastScore = s; }
                        if (displayedRank === 1) medalMap[p] = 'ü•á';
                        else if (displayedRank === 2) medalMap[p] = 'ü•à';
                        else if (displayedRank === 3) medalMap[p] = 'ü•â';
                    });
                }
                sortedPlayers.forEach(([player, score], index) => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = `final-player ${index === 0 ? 'winner' : ''}`;
                    const medal = medalMap[player] ? `<span class="medal">${medalMap[player]}</span>` : '';
                    let moneySpan = '';
                    if (this.bettingEnabled && this.amountPerPoint>0) {
                        const moneyNet = this.computeMoneyNet();
                        moneySpan = ` (‚Ç¨${this.formatMoney(moneyNet[player])})`;
                    }
                    playerDiv.innerHTML = `
                        <div class="result-players">${medal}${player}</div>
                        <div class="result-points">${score} points${moneySpan}</div>
                    `;
                    finalScores.appendChild(playerDiv);
                });
                if (this.bettingEnabled && this.amountPerPoint>0) {
                    const payoutHeader = document.createElement('div');
                    payoutHeader.style.marginTop = '20px';
                    payoutHeader.style.fontSize = '0.9rem';
                    payoutHeader.style.fontWeight = '600';
                    payoutHeader.style.letterSpacing = '.5px';
                    payoutHeader.textContent = 'Payouts';
                    finalScores.appendChild(payoutHeader);
                    const settlements = this.computeSettlements();
                    if (!settlements.length) {
                        const clearDiv = document.createElement('div');
                        clearDiv.style.fontSize = '.7rem';
                        clearDiv.style.opacity = '.7';
                        clearDiv.textContent = 'All square.';
                        finalScores.appendChild(clearDiv);
                    } else {
                        settlements.forEach(s => {
                            const row = document.createElement('div');
                            row.style.fontSize = '.7rem';
                            row.style.opacity = '.8';
                            row.style.display='flex';
                            row.style.justifyContent='space-between';
                            row.innerHTML = `<span>${s.from} ‚Üí ${s.to}</span><span>‚Ç¨${this.formatMoney(s.amount)}</span>`;
                            finalScores.appendChild(row);
                        });
                    }
                }
                this.saveState();
            }

            newGame() {
                // Alias to reset for backward compatibility with existing button
                this.resetToSetup();
            }

            resetToSetup() {
                // Clear data
                this.players = [];
                this.scores = {};
                this.holeResults = [];
                this.currentHoleResult = null;
                this.currentHole = 1;
                this.totalHoles = 18;
                this.currentWolf = 0;
                this.wolfHistory = [];
                this.currentHoleWinners = null;
                // Clear UI inputs
                ['player1','player2','player3','player4'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.value = '';
                });
                // Show setup, hide others
                document.getElementById('gameSetup').classList.remove('hidden');
                document.getElementById('holeScoring').classList.add('hidden');
                document.getElementById('gameSummary').classList.add('hidden');
                document.getElementById('winnerSelection').classList.add('hidden');
                const ch = document.getElementById('currentHole');
                if (ch){ ch.textContent=''; ch.classList.add('hidden','inactive'); }
                // Clear scoreboard
                document.getElementById('playersGrid').innerHTML = '';
                document.getElementById('scoreboard').classList.add('hidden');
                // Disable nav buttons
                document.getElementById('prevHoleBtn').disabled = true;
                document.getElementById('nextHoleBtn').disabled = true;
                // Reset player count to default 3-player mode
                playerCount = 3;
                document.getElementById('player4Group').style.display = 'none';
                document.getElementById('player3Btn').classList.add('selected');
                document.getElementById('player4Btn').classList.remove('selected');
                // Clear persisted state
                this.clearState();
                this.saveState();
                this.scrollToTop();
            }

            saveState() {
                try {
                  const state = {
                    version: this.stateVersion,
                    players: this.players,
                    currentHole: this.currentHole,
                    totalHoles: this.totalHoles,
                    currentWolf: this.currentWolf,
                    holeResults: this.holeResults,
                    scores: this.scores,
                    currentHoleResult: this.currentHoleResult,
                    rotationMode: this.rotationMode,
                    wolfOrder: this.wolfOrder,
                    wolfPointer: this.wolfPointer,
                    wolfHistory: this.wolfHistory,
                    bettingEnabled: this.bettingEnabled,
                    amountPerPoint: this.amountPerPoint
                  };
                  localStorage.setItem('wolfGameState', JSON.stringify(state));
                } catch(e){ console.warn('Failed to save state', e); }
              }
              loadState() {
                try {
                  const raw = localStorage.getItem('wolfGameState');
                  if (!raw) return false;
                  const data = JSON.parse(raw);
                  if (!data || data.version !== this.stateVersion) return false;
                  this.players = data.players || [];
                  this.currentHole = data.currentHole || 1;
                  this.totalHoles = data.totalHoles || 18;
                  this.currentWolf = data.currentWolf || 0;
                  this.holeResults = data.holeResults || [];
                  this.scores = data.scores || {};
                  this.currentHoleResult = data.currentHoleResult || null;
                  this.rotationMode = data.rotationMode || 'rolling';
                  this.wolfOrder = Array.isArray(data.wolfOrder) ? data.wolfOrder : [];
                  this.wolfPointer = typeof data.wolfPointer === 'number' ? data.wolfPointer : 0;
                  this.wolfHistory = Array.isArray(data.wolfHistory) && data.wolfHistory.length ? data.wolfHistory : (this.players.length ? [this.currentWolf] : []);
                  this.bettingEnabled = !!data.bettingEnabled;
                  this.amountPerPoint = parseFloat(data.amountPerPoint)||0;
                  this.currentHoleWinners = null;
                  if (this.players.length) {
                    this.updateScoreboard();
                    this.showHoleScoring();
                    this.updateNavigationButtons();
                    const rollingBtn = document.getElementById('rotationRollingBtn');
                    const randomBtn = document.getElementById('rotationRandomBtn');
                    if (rollingBtn && randomBtn) {
                      if (this.rotationMode === 'rolling') { rollingBtn.classList.add('selected'); randomBtn.classList.remove('selected'); }
                      else { randomBtn.classList.add('selected'); rollingBtn.classList.remove('selected'); }
                    }
                  }
                  return true;
                } catch(e){ console.warn('Failed to load state', e); return false; }
              }
              buildRandomWolfOrder() {
                const n = this.players.length;
                const total = this.totalHoles;
                if (!n) { this.wolfOrder = []; return; }
                const base = Math.floor(total / n);
                let rem = total % n;
                const counts = new Array(n).fill(base);
                const idxs = [...Array(n).keys()].sort(()=>Math.random()-0.5);
                for (let i=0;i<rem;i++) counts[idxs[i]]++;
                const order=[];
                counts.forEach((c,i)=>{ for(let k=0;k<c;k++) order.push(i); });
                for (let i=order.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [order[i],order[j]]=[order[j],order[i]]; }
                this.wolfOrder = order;
              }

                            formatMoney(v){
                                return v.toFixed(2).replace(/\.00$/,'');
                            }

                            computeMoneyNet(){
                                // Skins-style payout: only the point DIFFERENCE (max positive point value above 0) creates a single pot for the hole.
                                // That pot (maxPoints * stake) is split equally among all winners that achieved the max point value.
                                // All losers split the payment equally (so total paid == total received == maxPoints * stake).
                                // This prevents multi-player wins (e.g. partner team each +1) from doubling the money versus a solo win.
                                const net = {};
                                this.players.forEach(p=> net[p]=0);
                                if (!this.bettingEnabled || this.amountPerPoint<=0) return net;
                                const stake = this.amountPerPoint;
                                this.holeResults.forEach(hr => {
                                    if (!hr || !hr.pointsAwarded) return;
                                    const pa = hr.pointsAwarded;
                                    const pointValues = Object.values(pa);
                                    if (!pointValues.length) return; // tie or unscored
                                    const maxPts = Math.max(...pointValues);
                                    if (maxPts <= 0) return; // no positive winner points (shouldn't happen)
                                    // Winners are players with maxPts
                                    const winners = Object.keys(pa).filter(p => pa[p] === maxPts);
                                    const losers = this.players.filter(p => !winners.includes(p));
                                    if (!losers.length) return; // everyone won? (edge case) -> skip money
                                    const holePotMoney = maxPts * stake;
                                    const winShare = holePotMoney / winners.length;
                                    const loseShare = holePotMoney / losers.length;
                                    winners.forEach(w => net[w] += winShare);
                                    losers.forEach(l => net[l] -= loseShare);
                                });
                                return net;
                            }

                            computeSettlements(){
                                // Convert per-player net balances (from skins-style pot calculation) into minimal settlement transfers.
                                const net = this.computeMoneyNet();
                                const creditors = Object.entries(net).filter(([,v])=> v>0).map(([p,v])=>({p,v})).sort((a,b)=> b.v - a.v);
                                const debtors = Object.entries(net).filter(([,v])=> v<0).map(([p,v])=>({p,v:-v})).sort((a,b)=> b.v - a.v); // v positive as owed
                                const res=[];
                                let i=0,j=0;
                                while(i<debtors.length && j<creditors.length){
                                    const d = debtors[i];
                                    const c = creditors[j];
                                    const pay = Math.min(d.v, c.v);
                                    if (pay > 0.0001) res.push({from:d.p, to:c.p, amount: pay});
                                    d.v -= pay; c.v -= pay;
                                    if (d.v <= 0.0001) i++;
                                    if (c.v <= 0.0001) j++;
                                }
                                return res;
                            }
        }

        // Global game instance
        const game = new WolfGame();

        // Global variable to track player count
        let playerCount = 3;

    function setPlayerCount(count) {
            const player3Btn = document.getElementById('player3Btn');
            const player4Btn = document.getElementById('player4Btn');
            const player4Group = document.getElementById('player4Group');
            
            // Update global variable
            playerCount = count;
            
            // Update button states
            if (count === 3) {
                player3Btn.classList.add('selected');
                player4Btn.classList.remove('selected');
                player4Group.style.display = 'none';
            } else {
                player3Btn.classList.remove('selected');
                player4Btn.classList.add('selected');
                player4Group.style.display = 'block';
            }
            // Re-run stake estimate with new player count if betting panel visible
            if (typeof updateStakesEstimates === 'function') {
                updateStakesEstimates();
            }
        }

        function startGame() {
            const totalHoles = 18;
            const rawNames = [
                document.getElementById('player1').value.trim(),
                document.getElementById('player2').value.trim(),
                document.getElementById('player3').value.trim()
            ];
            if (playerCount === 4) rawNames.push(document.getElementById('player4').value.trim());
            const playerNames = rawNames.map((n,i)=> n===''?`Player ${i+1}`:n);
            game.initializeGame(playerNames,totalHoles);
        }

        function nextHole() {
            game.nextHole();
        }

        function previousHole() {
            game.previousHole();
        }

        function newGame() {
            game.newGame();
        }

        function resetGame() {
            showResetDialog();
        }
    // Ensure global exposure even if bundlers / strict scoping modifies context
    window.resetGame = resetGame;
        function showResetDialog(){
            document.getElementById('resetDialog').classList.remove('hidden');
            // focus first button
            const btn = document.querySelector('#resetDialog .btn-danger');
            if (btn) btn.focus();
        }
        function cancelReset(){
            document.getElementById('resetDialog').classList.add('hidden');
        }
        function confirmReset(){
            document.getElementById('resetDialog').classList.add('hidden');
            game.resetToSetup();
        }
        window.cancelReset = cancelReset;
        window.confirmReset = confirmReset;

        function setRotationMode(mode){
          const rollingBtn=document.getElementById('rotationRollingBtn');
          const randomBtn=document.getElementById('rotationRandomBtn');
          game.rotationMode = mode;
          if(mode==='rolling'){ rollingBtn.classList.add('selected'); randomBtn.classList.remove('selected'); }
          else { randomBtn.classList.add('selected'); rollingBtn.classList.remove('selected'); }
          game.saveState();
        }

        // DOMContentLoaded augmentation
// (Replace previous handler if present)
document.addEventListener('DOMContentLoaded', function() {
  document.getElementById('player4Group').style.display='none';
  document.getElementById('player3Btn').classList.add('selected');
  document.getElementById('player4Btn').classList.remove('selected');
  playerCount=3;
  setRotationMode('rolling');
  const restored = game.loadState();
    // Restore betting UI if state had it
    if (game.bettingEnabled) {
        const betChk = document.getElementById('bettingEnabled');
        const amtInput = document.getElementById('amountPerPoint');
        const row = document.getElementById('stakesAmountRow');
    const est = document.getElementById('stakesEstimatorRow');
        if (betChk) betChk.checked = true;
        if (amtInput) { amtInput.disabled = false; amtInput.value = game.amountPerPoint || ''; }
        if (row) row.style.display='flex';
    if (est) { est.style.display='flex'; setTimeout(updateStakesEstimates,0); }
    }
  if (restored && game.players.length === 4) {
    playerCount=4;
    document.getElementById('player4Group').style.display='block';
    document.getElementById('player3Btn').classList.remove('selected');
    document.getElementById('player4Btn').classList.add('selected');
  }
    document.addEventListener('keydown', e => { if (e.key === 'Escape') toggleOverview(false); });
});

function toggleOverview(force){
    const overlay = document.getElementById('overviewOverlay');
    if (!overlay) return;
    const isHidden = overlay.classList.contains('hidden');
    // Determine desired open state
    let open;
    if (typeof force === 'boolean') open = force; else open = isHidden; // if hidden -> open, else close
    if (open) {
        if (!game.players.length) return; // don't open with no game
        game.renderOverview();
        overlay.classList.remove('hidden');
    } else {
        overlay.classList.add('hidden');
    }
}
window.toggleOverview = toggleOverview;

// Backdrop click - close when clicking outside the panel
document.addEventListener('click', (e) => {
    const ov = document.getElementById('overviewOverlay');
    if (!ov || ov.classList.contains('hidden')) return;
    if (e.target === ov) toggleOverview(false);
});

function showModeSelection(){
    const modeSection = document.querySelector('.mode-selection');
    if (modeSection) modeSection.classList.remove('hidden');
    const winnerSel = document.getElementById('winnerSelection');
    // Keep winners visible; just unhide mode to allow re-select
}
window.showModeSelection = showModeSelection;

function toggleBettingInputs(){
    const betChk = document.getElementById('bettingEnabled');
    const amt = document.getElementById('amountPerPoint');
    const row = document.getElementById('stakesAmountRow');
    const est = document.getElementById('stakesEstimatorRow');
    if (!betChk || !amt) return;
    if (betChk.checked){ 
        amt.disabled = false; 
        if(row) row.style.display='flex'; 
        if(est) est.style.display='flex';
        amt.focus(); 
        updateStakesEstimates();
    }
    else { 
        amt.disabled = true; 
        if(row) row.style.display='none'; 
        if(est) est.style.display='none';
    }
}
window.toggleBettingInputs = toggleBettingInputs;

// Estimate worst-case max loss based on stake, players, and Tee Wolf frequency slider.
// Heuristic model: expected total points ~ basePoints + superWolfBoost.
// Updated for Option 2 (4P Tee 6 / Fairway 3):
// BasePoints (no Tee Wolf) ‚âà typical distribution using only Fairway + Partner: 3P ~38, 4P ~50 (slightly higher due to extra 1-point Fairway wins).
// Normal non-Tee hole average total points now ~2.6 (4P) / ~2.3 (3P). Tee Wolf hole totals range 6 + (2 * losers share) ‚âà 6 + (2 * avgOppShare) ~ 10‚Äì12 raw points spread; effective added total vs normal ‚âà 3.0 (3P) to 3.2 (4P) after averaging outcomes.
// We'll approximate incremental per Tee Wolf hole delta at 3.1 (4P) / 2.8 (3P).
// Slider % -> assumed count: freq% * 18 * 0.55 (Tee declarations not every hole; 0.55 tuned for new higher incentive).
// Individual max loss heuristic baseline share: (totalPoints * 0.52 / players) * stake (slightly higher 0.52 to reflect heavier tails).
// Volatility amplification widened to (0.85 .. 1.5) scaled by frequency and player count dispersion.
function estimateMaxLoss(playersCount, stake, superFreqPct){
    if (playersCount < 3 || stake <= 0) return 0;
    const holes = 18;
    const basePoints = playersCount === 3 ? 38 : 50; // slight bump for Fairway 3P vs 4P distribution
    const freq = superFreqPct / 100;
    const potentialTee = holes * 0.55; // tuned for new incentive frequency
    const teeCount = potentialTee * freq;
    const perHoleDelta = playersCount === 4 ? 3.1 : 2.8;
    const addedPoints = teeCount * perHoleDelta;
    const totalPoints = basePoints + addedPoints;
    // Worst-case cluster share estimate
    const baselineSpan = (totalPoints * 0.52 / playersCount);
    const swingMultiplier = playersCount === 4 ? 1.30 : 1.05; // slightly higher spread now with 6-point ceiling
    const volatility = (0.85 + freq * 0.65) * swingMultiplier; // expands top end to ~1.5
    return baselineSpan * volatility * stake;
}

function updateStakesEstimates(){
    const stakeInput = document.getElementById('amountPerPoint');
    const freqSlider = document.getElementById('teeWolfFreq');
    const freqLabel = document.getElementById('teeWolfFreqLabel');
    const out = document.getElementById('estimatedMaxLoss');
    const note = document.getElementById('estimateContextNote');
    if (!stakeInput || !freqSlider || !out) return;
    const stake = parseFloat(stakeInput.value)||0;
    const freq = parseInt(freqSlider.value,10)||0;
    if (freqLabel) freqLabel.textContent = freq + '%';
    const playersCount = (game && game.players && game.players.length) ? game.players.length : playerCount;
    const est = estimateMaxLoss(playersCount, stake, freq);
    if (stake > 0) {
        out.textContent = `Estimated max loss: ‚Ç¨${est.toFixed(2).replace(/\.00$/,'')}`;
    } else {
        out.textContent = 'Estimated max loss: ‚Äî';
    }
    if (note) {
        note.textContent = playersCount === 4
            ? '4P scaling active: Tee Wolf 6 / 2 each loss, Fairway 3 / 1 each.'
            : '3P scaling active: Tee Wolf 4 / 2 each loss, Fairway 2 / 1 each.';
    }
}
window.updateStakesEstimates = updateStakesEstimates;

function updateStakeSliderDisplay(){
    const slider = document.getElementById('amountPerPoint');
    const val = document.getElementById('amountPerPointValue');
    if (!slider || !val) return;
    const v = parseFloat(slider.value)||0;
    val.textContent = '‚Ç¨' + (v >= 1 ? v.toFixed(1).replace(/\.0$/,'') : v.toFixed(2));
}
window.updateStakeSliderDisplay = updateStakeSliderDisplay;

// React to stake amount changes
document.addEventListener('input', (e)=>{
    if (e.target && (e.target.id === 'amountPerPoint')) {
        updateStakesEstimates();
    }
});

function backToLastHole(){
    if (!game.players.length) return;
    document.getElementById('gameSummary').classList.add('hidden');
    // Set currentHole to last played hole (could be < total if ended early)
    const lastHole = game.holeResults.length ? game.holeResults[game.holeResults.length -1].hole : game.currentHole;
    game.currentHole = lastHole;
    if (game.wolfHistory[lastHole-1] !== undefined) game.currentWolf = game.wolfHistory[lastHole-1];
    game.showHoleScoring();
}
window.backToLastHole = backToLastHole;

    </script>
</body>
</html>
